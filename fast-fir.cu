/* Frederich Stine - EN605.617 FIR Project
*  fast-fir.cu
*  
*  This is the main file for the fast-fir project.
*  This project runs arbitrary FIR filters generated by pyfda across
*  16-bit signed mono wav files at any sampling rate.
*  This project performs GPU FIR filtering with Cuda and CPU FIR filtering
*  with a custom written implementation.
*  This project implements CPU FFTs with the FFTW3 library and GPU FFTs with
*  cuFFT.
*/ 

/******************* Includes ********************/
// Standard library includes
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include <math.h>
#include <chrono>

// FFT includes
#include <cufft.h>
#include <fftw3.h>

// Custom class includes
#include "filter_parse.h"
#include "wav_parse.h"

/******************* CUDA Kernel Prototypes ********************/
__global__ 
void gpuFIRKernel(double* filter, double* audio, 
	double* audioOut, int filterLen, int workSize);
__global__
void gpuMagnitude(cufftDoubleComplex* fftResult, double* output, int resultSize);
__global__
void gpuSum(double* input, double* output, double run, int resultSize);
__global__
void gpuDiv(double* input, double run, int resultSize);
__global__
void gpuDB(double* output, int resultSize);


/******************* Core Function Prototypes ********************/
// Function to run an FFT on a simple audio file
void cpuFIR(filterParse* filter, wavParse* audio, wavWrite* audioOut);
void gpuFIR(filterParse* filter, wavParse* audio, wavWrite* audioOut);
void gpuFFT(wavParse* audio, int fftSize, char* fileName);
void cpuFFT(wavParse* audio, int fftSize, char* fileName);


/******************* Helper Function Prototypes ********************/
void printFFTResults(double* buffer, int fftSize, int sampleRate);
void writeFFTResults(double* buffer, int fftSize, int sampleRate, char* fileName);


/******************* Funtion definitions ********************/
int main (int argc, char** argv) {
	// Prints out a help menu if not enough params are passed
	if (argc != 6) {
		printf("Error: Correct usage is\n");
		printf("     : ./fast-fir filter audioFileIn audioFileOut {operation} {fftSize}\n");
		printf("     : operation :\n");
		printf("                 : 0 - CPU\n");
		printf("                 : 1 - GPU\n");
		exit(0);
	}

	// Open all files for reading/writing
	filterParse* filter = new filterParse(argv[1]);
	wavParse* audio = new wavParse(argv[2]);
	wavWrite* audioOut = new wavWrite(argv[3]);
	audioOut->writeHeader(&audio->header);

	// Print out informtaion about WAV file
	audio->printInfo();

	audio->workSize = 20000;

	int operation = atoi(argv[4]);
	int fftSize = atoi(argv[5]);
	
	// Switch for CPU or GPU filtering
	switch (operation) {
		case 0:
			cpuFIR(filter, audio, audioOut);
			break;
		case 1:
			gpuFIR(filter, audio, audioOut);
			break;
		default:
			printf("Error: Operation is invalid\n");
			exit(0);
	}

	// Close written filtered audio file and re-open for reading
	delete(audioOut);
	wavParse* filteredAudio = new wavParse(argv[3]);
	
	// Switch for CPU or GPU FFT
	switch (operation) {
		case 0:
			cpuFFT(audio, fftSize, "FFT_Results_CPU_noFilter.txt");
			cpuFFT(filteredAudio, fftSize, "FFT_Results_CPU_Filter.txt");
			break;
		case 1:
			gpuFFT(audio, fftSize, "FFT_Results_GPU_noFilter.txt");
			gpuFFT(filteredAudio, fftSize, "FFT_Results_GPU_Filter.txt");
			break;
	}

	// Clean up all objects
	delete(filteredAudio);
	delete(filter);
	delete(audio);
}

/* CPU FIR filtering function
*  
*  This function takes in an audio file, filter, and audio write object
*  and uses a custom CPU FIR functionality to filter a file using the CPU.
*/ 
void cpuFIR(filterParse* filter, wavParse* audio, wavWrite* audioOut) {
	
	// Start timer
	std::chrono::time_point startTime = std::chrono::high_resolution_clock::now();

	// Priming read
	size_t workSize = audio->loadWorkSize(filter->len);
	while (workSize > filter->len) {
		// Apply custom written FIR filtering functionality
		double temp = 0;
		for (int x=0; x<(workSize-filter->len); x++) {
			temp = 0;
			for (int i=x; i<(filter->len+x); i++) {
				temp += audio->audioBuf[i] * filter->coeffArr[i-x];
			}
			// Write result to wav file
			audioOut->writeSample(temp);
		}

		// Load next data
		workSize = audio->loadWorkSize(filter->len);
	}

	// End timer
	std::chrono::time_point stopTime = std::chrono::high_resolution_clock::now();
	auto ns = std::chrono::duration<double>(stopTime - startTime);
	printf("CPU FIR Runtime: %lfs\n", ns.count());
}

/* GPU FIR filtering function
*  
*  This function takes in an audio file, filter, and audio write object
*  and uses a custom GPU FIR kernel to filter a file using the GPU.
*/ 
void gpuFIR(filterParse* filter, wavParse* audio, wavWrite* audioOut) {
	// Allocate device memory
	double *filterBuf, *audioBuf, *audioOutBuf;

	cudaMalloc((void**)&filterBuf, filter->len*(sizeof(double)));
	cudaMalloc((void**)&audioBuf, audio->workSize*(sizeof(double)));
	cudaMalloc((void**)&audioOutBuf, audio->workSize*(sizeof(double)));

	// Allocate host memory
	double *audioOutBufHost;
	cudaMallocHost((void**)&audioOutBufHost, audio->workSize*(sizeof(double)));

	// Copy filter to GPU
	cudaMemcpy(filterBuf, filter->coeffArr, filter->len*(sizeof(double)), cudaMemcpyHostToDevice);

	// Start timer
	std::chrono::time_point startTime = std::chrono::high_resolution_clock::now();

	// Priming read
	size_t workSize = audio->loadWorkSize(filter->len);
	while (workSize > filter->len) {
		// Calculate work sizes based on quantity of values read
		int batchSize = workSize - filter->len;
		int blockSize = 64;
		int numBlocks = batchSize+(blockSize-1) / blockSize;

		// Copy audio to GPU
		cudaMemcpy(audioBuf, audio->audioBuf, workSize*(sizeof(double)), cudaMemcpyHostToDevice);

		// Apply FIR kernel
		gpuFIRKernel<<<numBlocks, blockSize>>>(filterBuf, audioBuf, audioOutBuf, filter->len, workSize);

		// Copy result back
		cudaMemcpy(audioOutBufHost, audioOutBuf, audio->workSize*(sizeof(double)), cudaMemcpyDeviceToHost);

		// Write result to wav file
		audioOut->writeBulk(audioOutBufHost, workSize-filter->len);

		// Load next data
		workSize = audio->loadWorkSize(filter->len);
	}

	// End timer
	std::chrono::time_point stopTime = std::chrono::high_resolution_clock::now();
	auto ns = std::chrono::duration<double>(stopTime - startTime);
	printf("GPU FIR Runtime: %lfs\n", ns.count());

	// Free device memory
	cudaFree(filterBuf);
	cudaFree(audioBuf);
	cudaFree(audioOutBuf);

	// Free host memory
	cudaFreeHost(audioOutBufHost);
}

/* GPU FFT filtering function
*  
*  This function takes in an audio file, fftSize, and file name.
*  This function applies a FFT over the entire audio file and
*  averages the results into one FFT of the entire file.
*  This function uses the cuFFT library to perform the FFT on the GPU.
*/ 
void gpuFFT(wavParse* audio, int fftSize, char* fileName) {
	// Reset wav file pointer to start of audio
	audio->reset();

	// Determine some constants for the calculations
	int resultSize = (fftSize/2)+1;
	int resultSizeBytes = resultSize*sizeof(cufftDoubleComplex);
	int resultSizeMag = resultSize*sizeof(double);

	int blockSize = 64;
	int numBlocks = (fftSize+blockSize-1)/blockSize;
	int numBlocksResult = (resultSize+blockSize-1)/blockSize;

	float maxValue = ((pow(2, (float)audio->header.BitsPerSample))/2)-1.0;

	// Allocate device memory
	cufftDoubleReal* deviceAudio;
	cufftDoubleComplex* deviceFFT;
	double* deviceFFTMag;
	double* deviceFFTMagAvg;

	cudaMalloc((void **)&deviceAudio, \
			fftSize*sizeof(cufftDoubleReal));
	cudaMalloc((void **)&deviceFFT, resultSizeBytes);
	cudaMalloc((void **)&deviceFFTMag, resultSizeMag);
	cudaMalloc((void **)&deviceFFTMagAvg, resultSizeMag);

	// Allocate host memory
	double* hostFFTMagAvg = (double*) malloc (resultSize*sizeof(double));

	// Create a cufft plan for double real to complex transform
	cufftHandle plan;
	cufftPlan1d(&plan, fftSize, CUFFT_D2Z, 1);

	// Start timer
	std::chrono::time_point startTime = std::chrono::high_resolution_clock::now();

	// Priming read of data - cycle count initialization
	size_t bytesRead = audio->loadData(fftSize);
	double count = 1.0;
	while (bytesRead == fftSize) {
		// Copy over new data to GPU
		cudaMemcpy(deviceAudio, audio->audioBuf, \
				fftSize*sizeof(cufftDoubleReal),\
				cudaMemcpyHostToDevice);

		// Normalize audio data
		gpuDiv<<<numBlocks, blockSize>>>(deviceAudio, maxValue, fftSize);

		// Execute the fft
		cufftExecD2Z(plan, deviceAudio, deviceFFT);
		
		// Calculate magnitude and sum
		gpuMagnitude<<<numBlocksResult, blockSize>>>(deviceFFT, deviceFFTMag, resultSize);
		gpuSum<<<numBlocksResult, blockSize>>>(deviceFFTMagAvg, deviceFFTMag, count, resultSize);

		// Load next work size
		bytesRead = audio->loadData(fftSize);
		count++;
	}
	
	// Post FFT calculations - averaging and DB calculation
	gpuDiv<<<numBlocksResult, blockSize>>>(deviceFFTMagAvg, count, resultSize);
	gpuDB<<<numBlocksResult, blockSize>>>(deviceFFTMagAvg, resultSize);

	// Copy result to host
	cudaMemcpy(hostFFTMagAvg, deviceFFTMagAvg, \
		resultSizeMag, cudaMemcpyDeviceToHost);

	// End timer
	std::chrono::time_point stopTime = std::chrono::high_resolution_clock::now();
	auto ns = std::chrono::duration<double>(stopTime - startTime);
	printf("GPU FFT Runtime: %lfs\n", ns.count());

	//printFFTResults(hostFFTMagAvg, fftSize, audio->header.SampleRate);
	writeFFTResults(hostFFTMagAvg, fftSize, audio->header.SampleRate, fileName);

	// Free host memory
	free(hostFFTMagAvg);

	// Free plan
	cufftDestroy(plan);

	// Free device memory
	cudaFree(deviceAudio);
	cudaFree(deviceFFT);
	cudaFree(deviceFFTMag);
	cudaFree(deviceFFTMagAvg);
}

/* CPU FFT filtering function
*  
*  This function takes in an audio file, fftSize, and file name.
*  This function applies a FFT over the entire audio file and
*  averages the results into one FFT of the entire file.
*  This function uses the FFTW3 library to perform the FFT on the CPU.
*/ 
void cpuFFT(wavParse* audio, int fftSize, char* fileName) {
	// Reset wav file pointer to start of audio
	audio->reset();

	// Determine some constants for the calculations
	int resultSize = (fftSize/2)+1;
	float maxValue = ((pow(2, (float)audio->header.BitsPerSample))/2)-1.0;

	// Allocate host memory
	double* magnitude = (double*) malloc(resultSize*sizeof(double));
	double* magnitudeAvg = (double*) malloc(resultSize*sizeof(double));
	double* magnitudeDbAvg = (double*) malloc(resultSize*sizeof(double));
	fftw_complex* fftResult = (fftw_complex*) malloc(resultSize*sizeof(fftw_complex));

	// Initialize magnitudeAvg to zero
	for (int i=0; i<resultSize; i++) {
		magnitudeAvg[i] = 0.0;
	}

	// Create fft plan for fftw
	fftw_plan plan;
	
	// Start timer
	std::chrono::time_point startTime = std::chrono::high_resolution_clock::now();

	// Priming read of data - cycle count initialization
	size_t bytesRead = audio->loadData(fftSize);
	double count = 1.0;
	//input = (fftw_complex*) malloc(fftSize*sizeof(fftw_complex));
	while (bytesRead == fftSize) {
		// Normalize audio data
		for (int i=0; i<fftSize; i++) {
			audio->audioBuf[i] = audio->audioBuf[i]/maxValue;
		}
		
		// Execute the fft
		plan = fftw_plan_dft_r2c_1d(fftSize, audio->audioBuf, fftResult, FFTW_ESTIMATE);
		fftw_execute(plan);

		// Calculate magnitude and sum
		for (int i=0; i<resultSize; i++) {
			magnitude[i] = sqrt(pow(fftResult[i][0], 2) + pow(fftResult[i][1], 2));
			magnitudeAvg[i] += magnitude[i];
		}		

		// Load next work size
		bytesRead = audio->loadData(fftSize);
		count++;
	}

	// Post FFT calculations - averaging and DB calculation
	for (int i=0; i<resultSize; i++) {
		magnitudeAvg[i] = magnitudeAvg[i]/count;
		magnitudeDbAvg[i] = 20*log10(magnitudeAvg[i]);
	}

	// End timer
	std::chrono::time_point stopTime = std::chrono::high_resolution_clock::now();
	auto ns = std::chrono::duration<double>(stopTime - startTime);
	printf("CPU FFT Runtime: %lfs\n", ns.count());

	//printFFTResults(magnitudeDbAvg, fftSize, audio->header.SampleRate);
	writeFFTResults(magnitudeDbAvg, fftSize, audio->header.SampleRate, fileName);

	// Free host memory
	free(magnitudeDbAvg);
	free(magnitudeAvg);
	free(magnitude);
	free(fftResult);

}


/******************* CUDA Kernel Definitions ********************/
/** GPU FIR Kernel
 *  This kernel applies a FIR filter convolution to the input data
*/
__global__ 
void gpuFIRKernel(double* filter, double* audio, 
	double* audioOut, int filterLen, int workSize) {
	// Calculate index
	const unsigned int thread_idx = (blockIdx.x * blockDim.x) + threadIdx.x;

	// Return if greater than work size
	if (thread_idx >= workSize-filterLen) {
		return;
	}

	// Calculate convolution value for point in work
	double temp = 0;
	for (int i=0; i<filterLen; i++) {
		temp += audio[i+thread_idx] * filter[i];
	}

	// Place result into output
	audioOut[thread_idx] = temp;
}

/** GPU Magnitude Calculation
 *  This kernel calculates magnitude of a complex signal
*/
__global__
void gpuMagnitude(cufftDoubleComplex* fftResult, double* output, int resultSize) {

	// Calculate index
	const unsigned int thread_idx = (blockIdx.x * blockDim.x) + threadIdx.x;
	
	// Return if greater than work size
	if (thread_idx >= resultSize) {
		return;
	}

	// Calculate magnitude into output
	output[thread_idx] = sqrt(pow(fftResult[thread_idx].x, 2) + pow(fftResult[thread_idx].y, 2));
}

/** GPU Summation Kernel
 *  This kernel sums two values into the first value
*/
__global__
void gpuSum(double* input, double* output, double run, int resultSize) {
	// Calculate index
	const unsigned int thread_idx = (blockIdx.x * blockDim.x) + threadIdx.x;

	// Return if greater than work size
	if (thread_idx >= resultSize) {
		return;
	}

	// Sum values - if first initialize
	if (run == 1.0) {
		input[thread_idx] = output[thread_idx];
	}
	else {
		input[thread_idx] += output[thread_idx];
	}
}

/** GPU Division Kernel
 *  This kernel divides two values into the first value
*/
__global__
void gpuDiv(double* input, double div, int resultSize) {
	// Calculate index
	const unsigned int thread_idx = (blockIdx.x * blockDim.x) + threadIdx.x;

	// Return if greater than work size
	if (thread_idx >= resultSize) {
		return;
	}

	// Divide into output
	input[thread_idx] = input[thread_idx]/div;
}

/** GPU DB Kernel
 *  This kernel calculates the strength in DB
*/
__global__
void gpuDB(double* output, int resultSize) {
	// Calculate index
	const unsigned int thread_idx = (blockIdx.x * blockDim.x) + threadIdx.x;

	// Return if greater than work size
	if (thread_idx >= resultSize) {
		return;
	}

	// Calculate DB into output
	output[thread_idx] = 20*log10(output[thread_idx]);
}


/******************* Helper Function Definitions ********************/

/** Print FFT Results function
 * 
 *  This funtion takes in FFT reuslts, the FFT Size, and the sample rate
 *  and outputs the frequency distribution calculated by the FFT to stdout.
*/
void printFFTResults(double* buffer, int fftSize, int sampleRate) {
	for (int i=0; i<(fftSize/2)+1; i++) {
		float frequency = (float)i*(float)sampleRate/(float)fftSize;
		printf("FFT Result: Frequency: %f: Magnitude dB: %f\n", \
				frequency, buffer[i]);
	}
}

/** Write FFT Results function
 * 
 *  This funtion takes in FFT reuslts, the FFT Size, and the sample rate
 *  and outputs the frequency distribution calculated by the FFT to the given file name.
*/
void writeFFTResults(double* buffer, int fftSize, int sampleRate, char* fileName) {
	FILE* fh = fopen(fileName, "w");
	if (fh==NULL) {
		printf("Error: Failed to write FFT results\n");
		exit(0);
	}

	for (int i=0; i<(fftSize/2)+1; i++) {
		float frequency = (float)i*(float)sampleRate/(float)fftSize;
		fprintf(fh, "FFT Result: Frequency: %f: Magnitude dB: %f\n", \
				frequency, buffer[i]);
	}

	fclose(fh);
}